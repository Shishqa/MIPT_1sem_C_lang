/*
 * ms_linked_list_methods.h
 *
 *  Created on: 29 окт. 2019 г.
 *      Author: shishqa
 */

#ifndef MS_LINKED_LIST_METHODS_H_
#define MS_LINKED_LIST_METHODS_H_

template <typename elem_t>
int cmp(const void *a, const void *b)
{
	return comp_logic_pos<elem_t>(*((Node<elem_t> *)a), *((Node<elem_t> *)b));
}

template <typename elem_t>
int comp_logic_pos(Node<elem_t> a, Node<elem_t> b)
{
	return (a.next - b.next);
}

template <typename elem_t>
bool LinkedList<elem_t>::init(const size_t size)
{
	this->data = (Node<elem_t> *)calloc(size, sizeof(*this->data));

	this->data[0].init(this->POISON, DEADLOCK, DEADLOCK);

	for (size_t i = 1; i < size - 1; i++)
	{
		this->data[i].init(this->POISON, i + 1, EMPTY_MARKER);
	}

	this->data[size - 1].init(this->POISON, DEADLOCK, EMPTY_MARKER);

	this->empty = 1;
	this->head = DEADLOCK;
	this->tail = DEADLOCK;

	this->max_size = size;
	this->size = 0;

	this->aligned = false;

	this->dump_cnt = 0;

	return (true);
}

template <typename elem_t>
size_t LinkedList<elem_t>::getSize()
{
	return this->size;
}

template <typename elem_t>
elem_t LinkedList<elem_t>::getHead()
{
	return this->data[this->head].val;
}

template <typename elem_t>
elem_t LinkedList<elem_t>::getTail()
{
	return this->data[this->tail].val;
}

template <typename elem_t>
bool LinkedList<elem_t>::isAligned()
{
	return this->aligned;
}

template <typename elem_t>
bool LinkedList<elem_t>::clear()
{
	free(this->data);

	this->max_size = 0;

	return (true);
}

template <typename elem_t>
void LinkedList<elem_t>::dump(FILE *log)
{
	fprintf(log, "LinkedList [%p]\n", this);
	fprintf(log, "size = %lu\n", this->size);
	fprintf(log, "max_size = %lu\n", this->max_size);
	fprintf(log, "%saligned\n", ((this->aligned) ? "" : "not "));
	fprintf(log, "-------------------------------------------\n");
	fprintf(log, "i\t|\tval\tnext\tprev\n");

	for (size_t i = 0; i < this->max_size; i++)
	{
		fprintf(log, "%lu ", i);
		fprintf(log, "%s", ((i == this->head) ? ("H") : ("")));
		fprintf(log, "%s", ((i == this->tail) ? ("T") : ("")));
		fprintf(log, "%s", ((i == this->empty) ? ("E") : ("")));
		fprintf(log, "\t|\t");
		fprintf(log, "%d%s\t%d\t%d\n", this->data[i].val,
				((this->data[i].val == this->POISON) ? ("(P)") : ("")),
				this->data[i].next, this->data[i].prev);
	}

	fprintf(log, "-------------------------------------------\n");
}

template <typename elem_t>
void LinkedList<elem_t>::graphDump()
{
	system("mkdir -p tmp");

	FILE *log = fopen("tmp/tempautogeneratedlog.gv", "w");

	fprintf(log, "digraph DUMP \n{\n");

	fprintf(log, "rankdir = \"LR\";");

	for (size_t i = 0; i < this->max_size; i++)
	{
		if (i == this->head)
		{
			fprintf(log, "\t\"%p\" [shape = \"record\", label = \"head|adress: %d|value: %d|next: %d|prev: %d\"];\n",
					this->data + i, i, this->data[i].val, this->data[i].next, this->data[i].prev);
		}
		else if (i == this->tail)
		{
			fprintf(log, "\t\"%p\" [shape = \"record\", label = \"tail|adress: %d|value: %d|next: %d|prev: %d\"];\n",
					this->data + i, i, this->data[i].val, this->data[i].next, this->data[i].prev);
		}
		else if (i == this->empty)
		{
			fprintf(log, "\t\"%p\" [shape = \"record\", label = \"empty|adress: %d|value: %d|next: %d|prev: %d\"];\n",
					this->data + i, i, this->data[i].val, this->data[i].next, this->data[i].prev);
		}
		else
		{
			fprintf(log, "\t\"%p\" [shape = \"record\", label = \"adress: %d|value: %d|next: %d|prev: %d\"];\n",
					this->data + i, i, this->data[i].val, this->data[i].next, this->data[i].prev);
		}
	}

	fprintf(log, "\n");

	for (int i = this->head; i != this->tail; i = this->data[i].next)
	{
		fprintf(log, "\t\"%p\" -> \"%p\";\n", this->data + i, this->data + this->data[i].next);
	}

	fprintf(log, "\n");

	for (int i = this->empty; i != DEADLOCK; i = this->data[i].next)
	{
		fprintf(log, "\t\"%p\" -> \"%p\";\n", this->data + i, this->data + this->data[i].next);
	}

	fprintf(log, "}\n");

	fclose(log);

	system("mkdir -p log");

	char call_dot[100] = "";

	sprintf(call_dot, "dot -Tpng -olog/dump%d.png tmp/tempautogeneratedlog.gv", ++this->dump_cnt);

	system(call_dot);

	system("rm -R tmp");
}

template <typename elem_t>
int LinkedList<elem_t>::insertAfter(const int index, const elem_t val)
{
	if (this->size == 0 || index <= 0 || index > this->size ||
		this->empty == DEADLOCK || this->data[index].prev == EMPTY_MARKER)
	{
		return (DEADLOCK);
	}

	this->aligned = false;

	int nest_index = this->empty;
	this->empty = this->data[this->empty].next;

	this->data[nest_index].init(val, this->data[index].next, index);

	if (this->data[index].next != DEADLOCK)
	{
		this->data[this->data[nest_index].next].prev = nest_index;
	}
	else
	{
		this->tail = nest_index;
	}

	this->data[index].next = nest_index;

	this->size++;

	return (nest_index);
}

template <typename elem_t>
int LinkedList<elem_t>::insertBefore(const int index, const elem_t val)
{
	if (this->size == 0 || index <= 0 || index > this->size ||
		this->empty == DEADLOCK || this->data[index].prev == EMPTY_MARKER)
	{
		return (DEADLOCK);
	}

	this->aligned = false;

	int nest_index = this->empty;
	this->empty = this->data[this->empty].next;

	this->data[nest_index].init(val, index, this->data[index].prev);

	if (this->data[index].prev != DEADLOCK)
	{
		this->data[this->data[nest_index].prev].next = nest_index;
	}
	else
	{
		this->head = nest_index;
	}

	this->data[index].prev = nest_index;

	this->size++;

	return (nest_index);
}

template <typename elem_t>
int LinkedList<elem_t>::insertBack(const elem_t val)
{
	if (this->empty == DEADLOCK)
	{
		return (DEADLOCK);
	}

	this->aligned = false;

	int nest_index = this->empty;
	this->empty = this->data[this->empty].next;

	if (this->size == 0)
	{
		this->data[nest_index].init(val, DEADLOCK, DEADLOCK);
		this->head = nest_index;
		this->tail = nest_index;
	}
	else
	{
		this->data[nest_index].init(val, DEADLOCK, this->tail);
		this->data[this->tail].next = nest_index;
		this->tail = nest_index;
	}

	this->size++;

	return (nest_index);
}

template <typename elem_t>
int LinkedList<elem_t>::insertFront(const elem_t val)
{
	if (this->empty == DEADLOCK)
	{
		return (DEADLOCK);
	}

	this->aligned = false;

	int nest_index = this->empty;
	this->empty = this->data[this->empty].next;

	if (this->size == 0)
	{
		this->data[nest_index].init(val, DEADLOCK, DEADLOCK);
		this->head = nest_index;
		this->tail = nest_index;
	}
	else
	{
		this->data[nest_index].init(val, this->head, DEADLOCK);
		this->data[this->head].prev = nest_index;
		this->head = nest_index;
	}

	this->size++;

	return (nest_index);
}

template <typename elem_t>
int LinkedList<elem_t>::remove(const int index)
{
	if (this->size == 0 || index <= 0 || index > this->size ||
		this->data[index].prev == EMPTY_MARKER)
	{
		return (DEADLOCK);
	}

	this->aligned = false;

	if (index == this->head)
	{
		this->head = this->data[index].next;
	}
	else
	{
		this->data[this->data[index].prev].next = this->data[index].next;
	}

	if (index == this->tail)
	{
		this->tail = this->data[index].prev;
	}
	else
	{
		this->data[this->data[index].next].prev = this->data[index].prev;
	}

	this->data[index].clear(this->POISON, this->empty);

	this->empty = index;

	this->size--;

	return (index);
}

template <typename elem_t>
bool LinkedList<elem_t>::alignIndexes()
{
	if (!this->valid())
	{
		return (false);
	}

	for (int i = this->tail, cnt = 0; i != DEADLOCK; i = this->data[i].prev, cnt++)
	{
		this->data[i].next = this->size - cnt + 1;
	}

	for (size_t i = 1, cnt = 1; i < this->max_size; i++)
	{
		if (this->data[i].prev == EMPTY_MARKER)
		{
			this->data[i].next = this->size + (cnt++) + 1;
		}
		else
		{
			this->data[i].prev = this->data[i].next - 2;
		}
	}

	qsort(this->data, this->max_size, sizeof(Node<elem_t>), &cmp<elem_t>);

	this->data[this->size].next = DEADLOCK;
	this->data[this->max_size - 1].next = DEADLOCK;

	this->head = 1;
	this->tail = this->size;
	this->empty = this->size + 1;

	this->aligned = true;

	return (true);
}

template <typename elem_t>
int LinkedList<elem_t>::findPhysicalPositionByValue(const elem_t val)
{
	for (int i = this->head; i != DEADLOCK; i = this->data[i].next)
	{
		if (this->data[i].val == val)
		{
			return (i);
		}
	}

	return (DEADLOCK);
}

template <typename elem_t>
int LinkedList<elem_t>::findPhysicalPositionByLogical(int index)
{
	if (index > this->size)
	{
		return (DEADLOCK);
	}

	if (index <= this->size / 2)
	{
		for (int i = this->head; i != DEADLOCK; i = this->data[i].next)
		{
			if (--index == 0)
			{
				return (i);
			}
		}
	}
	else
	{
		for (int i = this->tail; i != DEADLOCK; i = this->data[i].prev)
		{
			if (++index > this->size)
			{
				return (i);
			}
		}
	}

	return (DEADLOCK);
}

template <typename elem_t>
bool LinkedList<elem_t>::valid()
{
	if (!this->dataOK() || !this->emptyOK())
	{
		return (false);
	}

	return (true);
}

template <typename elem_t>
bool LinkedList<elem_t>::dataOK()
{
	size_t elem_cnt = 0;

	bool met_tail = false;

	for (int i = this->head; i != DEADLOCK; i = this->data[i].next)
	{
		elem_cnt++;

		if (i == this->tail && this->data[i].next == DEADLOCK)
		{
			met_tail = true;
			break;
		}

		if (i == this->head && this->data[i].prev != DEADLOCK)
		{
			//printf ("head is not head\n");
			return (false);
		}
		else if (i == this->head)
		{
			continue;
		}

		if (this->data[this->data[i].prev].next != i || this->data[this->data[i].next].prev != i)
		{
			//printf ("prev or next is not linked: %d\n", i);
			return (false);
		}

		if (elem_cnt > this->size)
		{
			//printf ("went over size\n");
			return (false);
		}
	}

	if (elem_cnt != this->size || !met_tail)
	{
		//printf ("counted: %lu\nexepted: %lu\n", this->size);
		return (false);
	}

	return (true);
}

template <typename elem_t>
bool LinkedList<elem_t>::emptyOK()
{
	size_t elem_cnt = 0;

	for (int i = this->empty; i != DEADLOCK; i = this->data[i].next)
	{
		elem_cnt++;

		if (this->data[i].prev != EMPTY_MARKER)
		{
			return (false);
		}

		if (elem_cnt > this->max_size)
		{
			return (false);
		}
	}

	if (elem_cnt != this->max_size - (this->size + 1))
	{
		//printf ("%lu != %lu\n", elem_cnt, this->max_size - this->size);
		return (false);
	}

	return (true);
}

#endif /* MS_LINKED_LIST_METHODS_H_ */
