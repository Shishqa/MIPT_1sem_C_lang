/*
 * disasm.cpp
 *
 *  Created on: 12 окт. 2019 г.
 *      Author: shishqa
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include "../../libraries/assert_ext.h"
#include "../../libraries/ms_stream/ms_stream.h"
#include "../../libraries/ms_stack/ms_stack.h"
#include "../../libraries/ms_label/ms_label.h"
#include "../config/config.h"
#include "../config/cmd_enum.h"
#include "disasm.h"

Err_n Disassembler (FILE* in, FILE* out, Labels* labels)
{
    if (in == nullptr)
    {
    	return (INPUT_ERR);
    }

    if (out == nullptr)
    {
    	return (OUTPUT_ERR);
    }

    ASSERT (in != nullptr);
    ASSERT (out != nullptr);

    char* buffer = nullptr;

    size_t size_of_file = Read (&buffer, in);

    ASSERT (buffer != nullptr)

    char* curr = buffer + sizeof (Signature);
    char* code_begin = curr;

    size_t curr_line = 1;
    int label_ptr = -1;

    while (curr < buffer + size_of_file)
    {
    	label_ptr = -1;

		if ((label_ptr = labels->getNum (curr - code_begin)) != -1)
		{
			fprintf (out, "label_%d:\n", label_ptr);
		}

		switch (*curr)
		{
			#define DEF_CMD( opcode, name, type, len, n_args, stack_args, code )           	\
																							\
			case CMD_##name: { fprintf (out, "\t%s ", #name);		     					\
							   curr = PrintArgs (out, curr, n_args, labels, type);			\
							   break; }

			//----------------------------------
			// autogenerated
			//----------------------------------
			#include "../config/cmd_defines.h"
			//----------------------------------
			// autogenerated
			//----------------------------------

			#undef DEF_CMD

			default:  free (buffer);
					  return (WRONG_CMD_ERR);
					  break;
		}

		++curr;
		++curr_line;
    }

    free (buffer);

    return (DISASM_OK);
}


char* PrintArgs (FILE* out, char* curr, int n_args, Labels* labels, int type)
{
	Argument arg = {};

	for (int i = 0; i < n_args; i++)
	{
		++curr;

		memcpy (&arg, curr, sizeof(Argument));

		if (!arg.int_param && !arg.reg_param)
		{
			curr += sizeof (Argument) - 1;

			break;
		}

		if (arg.mem_param)
		{
			fprintf (out, "[");
		}

		if (arg.reg_param)
		{
			fprintf (out, "%s", reg_names[(int)arg.reg]);
		}

		if (arg.sum_param)
		{
			fprintf (out, "+");
		}

		if (arg.int_param)
		{
			if (type == JUMP)
			{
			   fprintf (out, "label_%d", labels->getNum (arg.val));
			}
			else
			{
			   fprintf (out, "%d", arg.val);
			}
		}

		if (arg.mem_param)
		{
			fprintf (out, "]");
		}

		fprintf (out, " ");

		if (labels->getNum (arg.val) == -1 && type == JUMP)
		{

			labels->add ((char*)&arg.val, 4, arg.val);
		}

		curr += sizeof (Argument) - 1;
	}

	fprintf (out, "\n");

	return curr;
}






