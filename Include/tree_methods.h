#ifndef TREE_METHODS_H_
#define TREE_METHODS_H_

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "ms_stream.h"

#include "tree_class.h"

template <typename elem_t>
bool BinaryTree<elem_t>::init ()
{
    this->root = nullptr;

    this->dump_cnt = 0;

    return (true);
}

template <typename elem_t>
bool BinaryTree<elem_t>::init (const elem_t data)
{
    setNode (&this->root);

    this->root->init (data);

    this->dump_cnt = 0;

    return (true);
}

template <typename elem_t>
bool BinaryTree<elem_t>::init (const char * path, void (* reader) (char **, const void *))
{
    FILE* f = fopen (path, "r");

    assert (f != nullptr);

    char * buffer = nullptr;

    size_t sof_code = Read (&buffer, f);

    fclose (f);

    char * cur = buffer;

    assert (cur != nullptr);

    if (*cur != '{')
    {
        return (false);
    }

    setNode (&this->root);

    initSubtree (this->root, cur, reader);
}

template <typename elem_t>
char * BinaryTree<elem_t>::initSubtree (Node<elem_t> * node, char* cur, void (* reader) (char **, const void *))
{
    assert (cur != nullptr);
    assert (node != nullptr);

    cur += 1;

    reader (&cur, &(node->data));

    if (*cur == '{')
    {
        node->setLeft ();

        assert (node->left->parent == node);

        cur = initSubtree (node->left, cur, reader);

        if (*cur == '{')
        {
            node->setRight ();

            assert (node->right->parent == node);

            cur = initSubtree (node->right, cur, reader);
        }
    }
    else if (*cur == '$')
    {
        if (*(cur + 1) != '{')
        {
            printf ("expected { after $\n");
            return (nullptr);
        }

        node->setRight ();

        assert (node->right->parent == node);

        cur = initSubtree (node->right, ++cur, reader);
    }

    if (*cur != '}')
    {
        printf ("unclosed braces: %c\n", *cur);
        return (nullptr);
    }

    return (cur + 1);
}

template <typename elem_t>
Node<elem_t> * BinaryTree<elem_t>::setNode (Node<elem_t> ** ptr)
{
    *ptr = (Node<elem_t> *) calloc (1, sizeof (Node<elem_t>));

    return (*ptr);
}

template <typename elem_t>
bool BinaryTree<elem_t>::clear ()
{
    this->deleteSubtree (this->root);
}

template <typename elem_t>
bool BinaryTree<elem_t>::deleteList (Node<elem_t> * node)
{
    if (node->left || node->right)
    {
        return (false);
    }

    if (node->parent && node->parent->right == node)
    {
        node->parent->right = nullptr;
    }
    else if (node->parent)
    {
        node->parent->left  = nullptr;
    }

    free (node);

    return (true);
}

template <typename elem_t>
bool BinaryTree<elem_t>::deleteSubtree (Node<elem_t> * node)
{
    if (node->left)
    {
        this->deleteSubtree (node->left);
    }

    if (node->right)
    {
        this->deleteSubtree (node->right);
    }

    this->deleteList (node);

    return (true);
}

template <typename elem_t>
bool BinaryTree<elem_t>::print (FILE * log, const char mode, void (* printer) (FILE *, const void *),
                                const char left_brac, const char right_brac, const char sep)
{
    this->root->print (log, mode, printer, left_brac, right_brac, sep);

    return (true);
}

template <typename elem_t>
Node<elem_t> * BinaryTree<elem_t>::search (const elem_t data)
{
    return (this->rec_search (this->root, data));
}

template <typename elem_t>
Node<elem_t> * BinaryTree<elem_t>::rec_search (Node<elem_t> * node, const elem_t data)
{
    Node<elem_t> * res = nullptr;

    if (node->data == data)
    {
        return (node);
    }

    if (node->left)
    {
        res = this->rec_search (node->left, data);

        if (res)
        {
            return (res);
        }
    }

    if (node->right)
    {
        res = this->rec_search (node->right, data);

        if (res)
        {
            return (res);
        }
    }

    return (res);
}

template <typename elem_t>
bool BinaryTree<elem_t>::dotDump (void (* printer) (FILE *, const void *), int num)
{
    system("mkdir -p log");

    system("mkdir -p log/tmp");

	FILE *log = fopen("log/tmp/tempautogeneratedlog.gv", "w");

    fprintf (log, "digraph dump\n{\n");

    assert (this->root != nullptr);
    assert (printer != nullptr);
    assert (log != nullptr);

    this->root->printDot (log, printer);

    fprintf (log, "\n}\n");

    fclose(log);

	char call_dot[100] = "";

    if (num == 0)
    {
        sprintf(call_dot, "dot -Tpng -olog/dump%lu.png log/tmp/tempautogeneratedlog.gv", ++this->dump_cnt);
    }
	else
    {
        sprintf(call_dot, "dot -Tpng -olog/dump%d.png log/tmp/tempautogeneratedlog.gv", num);
    }

	system(call_dot);

    return (true);
}

template <typename elem_t>
bool BinaryTree<elem_t>::valid (Node<elem_t> * node)
{
    return (true);
}

#endif // !TREE_METHODS_H_